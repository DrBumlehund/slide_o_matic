/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.f18.dsl.external.services.SlideOMaticGrammarAccess;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Authors;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CompileDate;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CurrentSecToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Div;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ExactSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FileCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Height;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.InlineCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Institute;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Jump;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Let;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.LineSequence;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ListItem;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.MathExp;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Minus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Move;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Mult;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Num;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Plus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Pow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Presentation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ProportionalSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Sec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SlideOMaticPackage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Table;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TableRow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Text;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Theme;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.UnNumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Var;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Width;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SlideOMaticSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SlideOMaticGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SlideOMaticPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SlideOMaticPackage.ANIMATION:
				sequence_Animation(context, (Animation) semanticObject); 
				return; 
			case SlideOMaticPackage.AUTHORS:
				sequence_Authors(context, (Authors) semanticObject); 
				return; 
			case SlideOMaticPackage.BLOCK:
				if (rule == grammarAccess.getBlockRule()) {
					sequence_Block(context, (Block) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getContentRule()) {
					sequence_Block_Content(context, (Block) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.COMPILE_DATE:
				sequence_Date(context, (CompileDate) semanticObject); 
				return; 
			case SlideOMaticPackage.CURRENT_SEC_TO_C:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_ToC(context, (CurrentSecToC) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getToCRule()) {
					sequence_ToC(context, (CurrentSecToC) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case SlideOMaticPackage.DIV:
				sequence_Factor(context, (Div) semanticObject); 
				return; 
			case SlideOMaticPackage.EXACT_SIZE:
				sequence_Size(context, (ExactSize) semanticObject); 
				return; 
			case SlideOMaticPackage.FILE_CODE:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Code_Content(context, (FileCode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCodeRule()) {
					sequence_Code(context, (FileCode) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.HEIGHT:
				sequence_Way(context, (Height) semanticObject); 
				return; 
			case SlideOMaticPackage.IMAGE:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_Image(context, (Image) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImageRule()) {
					sequence_Image(context, (Image) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.INLINE_CODE:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Code_Content(context, (InlineCode) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCodeRule()) {
					sequence_Code(context, (InlineCode) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.INSTITUTE:
				sequence_Institute(context, (Institute) semanticObject); 
				return; 
			case SlideOMaticPackage.JUMP:
				sequence_AnimationType(context, (Jump) semanticObject); 
				return; 
			case SlideOMaticPackage.LET:
				sequence_VariableBinding(context, (Let) semanticObject); 
				return; 
			case SlideOMaticPackage.LINE_SEQUENCE:
				sequence_LineSequence(context, (LineSequence) semanticObject); 
				return; 
			case SlideOMaticPackage.LIST_ITEM:
				sequence_ListItem(context, (ListItem) semanticObject); 
				return; 
			case SlideOMaticPackage.MATH_EXP:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_MathExp(context, (MathExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMathExpRule()) {
					sequence_MathExp(context, (MathExp) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.MINUS:
				sequence_Exp(context, (Minus) semanticObject); 
				return; 
			case SlideOMaticPackage.MOVE:
				sequence_AnimationType(context, (Move) semanticObject); 
				return; 
			case SlideOMaticPackage.MULT:
				sequence_Factor(context, (Mult) semanticObject); 
				return; 
			case SlideOMaticPackage.NUM:
				sequence_Number(context, (Num) semanticObject); 
				return; 
			case SlideOMaticPackage.NUMBERED_LIST:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_NumberedList(context, (NumberedList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getListRule()
						|| rule == grammarAccess.getNumberedListRule()) {
					sequence_NumberedList(context, (NumberedList) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.PLUS:
				sequence_Exp(context, (Plus) semanticObject); 
				return; 
			case SlideOMaticPackage.POW:
				sequence_Pow(context, (Pow) semanticObject); 
				return; 
			case SlideOMaticPackage.PRESENTATION:
				sequence_Presentation(context, (Presentation) semanticObject); 
				return; 
			case SlideOMaticPackage.PROPORTIONAL_SIZE:
				sequence_Size(context, (ProportionalSize) semanticObject); 
				return; 
			case SlideOMaticPackage.SEC:
				sequence_Section(context, (Sec) semanticObject); 
				return; 
			case SlideOMaticPackage.SLIDE:
				sequence_Slide(context, (Slide) semanticObject); 
				return; 
			case SlideOMaticPackage.SUB_SEC:
				sequence_Section(context, (SubSec) semanticObject); 
				return; 
			case SlideOMaticPackage.SUB_SUB_SEC:
				sequence_Section(context, (SubSubSec) semanticObject); 
				return; 
			case SlideOMaticPackage.TABLE:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_Table(context, (Table) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableRule()) {
					sequence_Table(context, (Table) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case SlideOMaticPackage.TEXT:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_Text(context, (Text) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTextRule()) {
					sequence_Text(context, (Text) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.THEME:
				sequence_Theme(context, (Theme) semanticObject); 
				return; 
			case SlideOMaticPackage.TO_C:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_ToC(context, (ToC) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getToCRule()) {
					sequence_ToC(context, (ToC) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.UN_NUMBERED_LIST:
				if (rule == grammarAccess.getContentRule()) {
					sequence_Content_UnNumberedList(context, (UnNumberedList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getListRule()
						|| rule == grammarAccess.getUnNumberedListRule()) {
					sequence_UnNumberedList(context, (UnNumberedList) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.VAR:
				sequence_VariableUse(context, (Var) semanticObject); 
				return; 
			case SlideOMaticPackage.WIDTH:
				sequence_Way(context, (Width) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnimationType returns Jump
	 *
	 * Constraint:
	 *     {Jump}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Jump semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnimationType returns Move
	 *
	 * Constraint:
	 *     {Move}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Animation returns Animation
	 *
	 * Constraint:
	 *     (target=[Image|ID] type=AnimationType location=Alignment size=Size?)
	 */
	protected void sequence_Animation(ISerializationContext context, Animation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Authors returns Authors
	 *
	 * Constraint:
	 *     (names+=STRING names+=STRING*)
	 */
	protected void sequence_Authors(ISerializationContext context, Authors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (name=STRING? content+=Content+)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Block
	 *
	 * Constraint:
	 *     (name=STRING? content+=Content+ click=Click?)
	 */
	protected void sequence_Block_Content(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns FileCode
	 *
	 * Constraint:
	 *     (lang=ID src=STRING (lines+=LineSequence lines+=LineSequence*)? click=Click?)
	 */
	protected void sequence_Code_Content(ISerializationContext context, FileCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns InlineCode
	 *
	 * Constraint:
	 *     (lang=ID code=STRING click=Click?)
	 */
	protected void sequence_Code_Content(ISerializationContext context, InlineCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns FileCode
	 *
	 * Constraint:
	 *     (lang=ID src=STRING (lines+=LineSequence lines+=LineSequence*)?)
	 */
	protected void sequence_Code(ISerializationContext context, FileCode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns InlineCode
	 *
	 * Constraint:
	 *     (lang=ID code=STRING)
	 */
	protected void sequence_Code(ISerializationContext context, InlineCode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.CODE__LANG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.CODE__LANG));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.INLINE_CODE__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.INLINE_CODE__CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCodeAccess().getLangIDTerminalRuleCall_0_2_0(), semanticObject.getLang());
		feeder.accept(grammarAccess.getCodeAccess().getCodeSTRINGTerminalRuleCall_0_3_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Image
	 *
	 * Constraint:
	 *     (name=ID src=STRING alignment=Alignment? size=Size click=Click?)
	 */
	protected void sequence_Content_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns MathExp
	 *
	 * Constraint:
	 *     (eval='eval'? exp=Exp click=Click?)
	 */
	protected void sequence_Content_MathExp(ISerializationContext context, MathExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns NumberedList
	 *
	 * Constraint:
	 *     (items+=ListItem+ click=Click?)
	 */
	protected void sequence_Content_NumberedList(ISerializationContext context, NumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Table
	 *
	 * Constraint:
	 *     (name=ID rows+=TableRow rows+=TableRow* click=Click?)
	 */
	protected void sequence_Content_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Text
	 *
	 * Constraint:
	 *     (text=STRING click=Click?)
	 */
	protected void sequence_Content_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns CurrentSecToC
	 *
	 * Constraint:
	 *     click=Click?
	 */
	protected void sequence_Content_ToC(ISerializationContext context, CurrentSecToC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns ToC
	 *
	 * Constraint:
	 *     click=Click?
	 */
	protected void sequence_Content_ToC(ISerializationContext context, ToC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns UnNumberedList
	 *
	 * Constraint:
	 *     (items+=ListItem+ click=Click?)
	 */
	protected void sequence_Content_UnNumberedList(ISerializationContext context, UnNumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns CompileDate
	 *
	 * Constraint:
	 *     {CompileDate}
	 */
	protected void sequence_Date(ISerializationContext context, CompileDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns Date
	 *
	 * Constraint:
	 *     date=STRING
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.DATE__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.DATE__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateAccess().getDateSTRINGTerminalRuleCall_1_0_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Minus
	 *     Exp.Plus_1_0_0_1 returns Minus
	 *     Exp.Minus_1_0_1_1 returns Minus
	 *     Factor returns Minus
	 *     Factor.Mult_1_0_0_1 returns Minus
	 *     Factor.Div_1_0_1_1 returns Minus
	 *     Pow returns Minus
	 *     Pow.Pow_1_0 returns Minus
	 *     Primary returns Minus
	 *     Parenthesis returns Minus
	 *
	 * Constraint:
	 *     (left=Exp_Minus_1_0_1_1 right=Factor)
	 */
	protected void sequence_Exp(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getMinusLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Plus
	 *     Exp.Plus_1_0_0_1 returns Plus
	 *     Exp.Minus_1_0_1_1 returns Plus
	 *     Factor returns Plus
	 *     Factor.Mult_1_0_0_1 returns Plus
	 *     Factor.Div_1_0_1_1 returns Plus
	 *     Pow returns Plus
	 *     Pow.Pow_1_0 returns Plus
	 *     Primary returns Plus
	 *     Parenthesis returns Plus
	 *
	 * Constraint:
	 *     (left=Exp_Plus_1_0_0_1 right=Factor)
	 */
	protected void sequence_Exp(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getPlusLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Div
	 *     Exp.Plus_1_0_0_1 returns Div
	 *     Exp.Minus_1_0_1_1 returns Div
	 *     Factor returns Div
	 *     Factor.Mult_1_0_0_1 returns Div
	 *     Factor.Div_1_0_1_1 returns Div
	 *     Pow returns Div
	 *     Pow.Pow_1_0 returns Div
	 *     Primary returns Div
	 *     Parenthesis returns Div
	 *
	 * Constraint:
	 *     (left=Factor_Div_1_0_1_1 right=Pow)
	 */
	protected void sequence_Factor(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getDivLeftAction_1_0_1_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Mult
	 *     Exp.Plus_1_0_0_1 returns Mult
	 *     Exp.Minus_1_0_1_1 returns Mult
	 *     Factor returns Mult
	 *     Factor.Mult_1_0_0_1 returns Mult
	 *     Factor.Div_1_0_1_1 returns Mult
	 *     Pow returns Mult
	 *     Pow.Pow_1_0 returns Mult
	 *     Primary returns Mult
	 *     Parenthesis returns Mult
	 *
	 * Constraint:
	 *     (left=Factor_Mult_1_0_0_1 right=Pow)
	 */
	protected void sequence_Factor(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getMultLeftAction_1_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Image returns Image
	 *
	 * Constraint:
	 *     (name=ID src=STRING alignment=Alignment? size=Size)
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Institute returns Institute
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Institute(ISerializationContext context, Institute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.INSTITUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.INSTITUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstituteAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LineSequence returns LineSequence
	 *
	 * Constraint:
	 *     (lower=INT upper=INT? additional+=LineSequence*)
	 */
	protected void sequence_LineSequence(ISerializationContext context, LineSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListItem returns ListItem
	 *
	 * Constraint:
	 *     (item=STRING nestedList=List? click=Click?)
	 */
	protected void sequence_ListItem(ISerializationContext context, ListItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathExp returns MathExp
	 *
	 * Constraint:
	 *     (eval='eval'? exp=Exp)
	 */
	protected void sequence_MathExp(ISerializationContext context, MathExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Num
	 *     Exp.Plus_1_0_0_1 returns Num
	 *     Exp.Minus_1_0_1_1 returns Num
	 *     Factor returns Num
	 *     Factor.Mult_1_0_0_1 returns Num
	 *     Factor.Div_1_0_1_1 returns Num
	 *     Pow returns Num
	 *     Pow.Pow_1_0 returns Num
	 *     Primary returns Num
	 *     Parenthesis returns Num
	 *     Number returns Num
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Number(ISerializationContext context, Num semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.NUM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.NUM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     List returns NumberedList
	 *     NumberedList returns NumberedList
	 *
	 * Constraint:
	 *     items+=ListItem+
	 */
	protected void sequence_NumberedList(ISerializationContext context, NumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Pow
	 *     Exp.Plus_1_0_0_1 returns Pow
	 *     Exp.Minus_1_0_1_1 returns Pow
	 *     Factor returns Pow
	 *     Factor.Mult_1_0_0_1 returns Pow
	 *     Factor.Div_1_0_1_1 returns Pow
	 *     Pow returns Pow
	 *     Pow.Pow_1_0 returns Pow
	 *     Primary returns Pow
	 *     Parenthesis returns Pow
	 *
	 * Constraint:
	 *     (left=Pow_Pow_1_0 right=Primary)
	 */
	protected void sequence_Pow(ISerializationContext context, Pow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.POW__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.POW__LEFT));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.POW__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.POW__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowAccess().getPowLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Presentation returns Presentation
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         subtitle=STRING? 
	 *         theme=Theme? 
	 *         authors=Authors? 
	 *         institute=Institute? 
	 *         date=Date? 
	 *         (slides+=Slide | animations+=Animation)*
	 *     )
	 */
	protected void sequence_Presentation(ISerializationContext context, Presentation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Sec
	 *
	 * Constraint:
	 *     {Sec}
	 */
	protected void sequence_Section(ISerializationContext context, Sec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSec
	 *
	 * Constraint:
	 *     {SubSec}
	 */
	protected void sequence_Section(ISerializationContext context, SubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSubSec
	 *
	 * Constraint:
	 *     {SubSubSec}
	 */
	protected void sequence_Section(ISerializationContext context, SubSubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Size returns ExactSize
	 *
	 * Constraint:
	 *     (size=INT (unit='cm' | unit='em' | unit='mm'))
	 */
	protected void sequence_Size(ISerializationContext context, ExactSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Size returns ProportionalSize
	 *
	 * Constraint:
	 *     (way=Way scale=INT)
	 */
	protected void sequence_Size(ISerializationContext context, ProportionalSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.PROPORTIONAL_SIZE__WAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.PROPORTIONAL_SIZE__WAY));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.PROPORTIONAL_SIZE__SCALE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.PROPORTIONAL_SIZE__SCALE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeAccess().getWayWayParserRuleCall_0_1_0(), semanticObject.getWay());
		feeder.accept(grammarAccess.getSizeAccess().getScaleINTTerminalRuleCall_0_2_0(), semanticObject.getScale());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns Slide
	 *
	 * Constraint:
	 *     (((sec=Section name=STRING) | name=STRING)? contents+=Content+)
	 */
	protected void sequence_Slide(ISerializationContext context, Slide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (values+=STRING values+=STRING*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (name=ID rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Text returns Text
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextAccess().getTextSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Theme returns Theme
	 *
	 * Constraint:
	 *     (theme=BeamerTheme themeColor=ThemeColor?)
	 */
	protected void sequence_Theme(ISerializationContext context, Theme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ToC returns CurrentSecToC
	 *
	 * Constraint:
	 *     {CurrentSecToC}
	 */
	protected void sequence_ToC(ISerializationContext context, CurrentSecToC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ToC returns ToC
	 *
	 * Constraint:
	 *     {ToC}
	 */
	protected void sequence_ToC(ISerializationContext context, ToC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns UnNumberedList
	 *     UnNumberedList returns UnNumberedList
	 *
	 * Constraint:
	 *     items+=ListItem+
	 */
	protected void sequence_UnNumberedList(ISerializationContext context, UnNumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Let
	 *     Exp.Plus_1_0_0_1 returns Let
	 *     Exp.Minus_1_0_1_1 returns Let
	 *     Factor returns Let
	 *     Factor.Mult_1_0_0_1 returns Let
	 *     Factor.Div_1_0_1_1 returns Let
	 *     Pow returns Let
	 *     Pow.Pow_1_0 returns Let
	 *     Primary returns Let
	 *     VariableBinding returns Let
	 *     Parenthesis returns Let
	 *
	 * Constraint:
	 *     (id=ID binding=Exp body=Exp)
	 */
	protected void sequence_VariableBinding(ISerializationContext context, Let semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.LET__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.LET__ID));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.LET__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.LET__BINDING));
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.LET__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.LET__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableBindingAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getVariableBindingAccess().getBindingExpParserRuleCall_4_0(), semanticObject.getBinding());
		feeder.accept(grammarAccess.getVariableBindingAccess().getBodyExpParserRuleCall_6_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exp returns Var
	 *     Exp.Plus_1_0_0_1 returns Var
	 *     Exp.Minus_1_0_1_1 returns Var
	 *     Factor returns Var
	 *     Factor.Mult_1_0_0_1 returns Var
	 *     Factor.Div_1_0_1_1 returns Var
	 *     Pow returns Var
	 *     Pow.Pow_1_0 returns Var
	 *     Primary returns Var
	 *     VariableUse returns Var
	 *     Parenthesis returns Var
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_VariableUse(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.VAR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.VAR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableUseAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Way returns Height
	 *
	 * Constraint:
	 *     {Height}
	 */
	protected void sequence_Way(ISerializationContext context, Height semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Way returns Width
	 *
	 * Constraint:
	 *     {Width}
	 */
	protected void sequence_Way(ISerializationContext context, Width semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
