/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.f18.dsl.external.services.SlideOMaticGrammarAccess;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Authors;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Institute;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Jump;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Move;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedListItem;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Paragraph;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Presentation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Sec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Size;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SlideOMaticPackage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TOC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Table;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TableRow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Theme;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.UnNumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.UnNumberedListItem;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SlideOMaticSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SlideOMaticGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SlideOMaticPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SlideOMaticPackage.ANIMATION:
				sequence_Animation(context, (Animation) semanticObject); 
				return; 
			case SlideOMaticPackage.AUTHORS:
				sequence_Authors(context, (Authors) semanticObject); 
				return; 
			case SlideOMaticPackage.BLOCK:
				sequence_Text(context, (Block) semanticObject); 
				return; 
			case SlideOMaticPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case SlideOMaticPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case SlideOMaticPackage.INSTITUTE:
				sequence_Institute(context, (Institute) semanticObject); 
				return; 
			case SlideOMaticPackage.JUMP:
				sequence_AnimationType(context, (Jump) semanticObject); 
				return; 
			case SlideOMaticPackage.MOVE:
				sequence_AnimationType(context, (Move) semanticObject); 
				return; 
			case SlideOMaticPackage.NUMBERED_LIST:
				sequence_List(context, (NumberedList) semanticObject); 
				return; 
			case SlideOMaticPackage.NUMBERED_LIST_ITEM:
				sequence_NumberedListItem(context, (NumberedListItem) semanticObject); 
				return; 
			case SlideOMaticPackage.PARAGRAPH:
				sequence_Text(context, (Paragraph) semanticObject); 
				return; 
			case SlideOMaticPackage.PRESENTATION:
				sequence_Presentation(context, (Presentation) semanticObject); 
				return; 
			case SlideOMaticPackage.SEC:
				if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (Sec) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (Sec) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.SIZE:
				sequence_Size(context, (Size) semanticObject); 
				return; 
			case SlideOMaticPackage.SLIDE:
				sequence_Slide(context, (Slide) semanticObject); 
				return; 
			case SlideOMaticPackage.SUB_SEC:
				if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (SubSec) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (SubSec) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.SUB_SUB_SEC:
				if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (SubSubSec) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (SubSubSec) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.TOC:
				sequence_Content(context, (TOC) semanticObject); 
				return; 
			case SlideOMaticPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case SlideOMaticPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case SlideOMaticPackage.THEME:
				sequence_Theme(context, (Theme) semanticObject); 
				return; 
			case SlideOMaticPackage.UN_NUMBERED_LIST:
				sequence_List(context, (UnNumberedList) semanticObject); 
				return; 
			case SlideOMaticPackage.UN_NUMBERED_LIST_ITEM:
				sequence_UnNumberedListItem(context, (UnNumberedListItem) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnimationType returns Jump
	 *
	 * Constraint:
	 *     {Jump}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Jump semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnimationType returns Move
	 *
	 * Constraint:
	 *     {Move}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Animation returns Animation
	 *
	 * Constraint:
	 *     (target=[Float|ID] type=AnimationType location=Alignment size=Size?)
	 */
	protected void sequence_Animation(ISerializationContext context, Animation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Authors returns Authors
	 *
	 * Constraint:
	 *     (names+=STRING names+=STRING*)
	 */
	protected void sequence_Authors(ISerializationContext context, Authors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns TOC
	 *
	 * Constraint:
	 *     {TOC}
	 */
	protected void sequence_Content(ISerializationContext context, TOC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns Date
	 *
	 * Constraint:
	 *     date=STRING
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.DATE__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.DATE__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateAccess().getDateSTRINGTerminalRuleCall_1_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Image
	 *     Float returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     (name=ID src=STRING alignment=Alignment? size=Size)
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Institute returns Institute
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Institute(ISerializationContext context, Institute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.INSTITUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.INSTITUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstituteAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Content returns NumberedList
	 *     List returns NumberedList
	 *
	 * Constraint:
	 *     ListItems+=NumberedListItem+
	 */
	protected void sequence_List(ISerializationContext context, NumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns UnNumberedList
	 *     List returns UnNumberedList
	 *
	 * Constraint:
	 *     ListItems+=UnNumberedListItem+
	 */
	protected void sequence_List(ISerializationContext context, UnNumberedList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumberedListItem returns NumberedListItem
	 *
	 * Constraint:
	 *     item=STRING
	 */
	protected void sequence_NumberedListItem(ISerializationContext context, NumberedListItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.NUMBERED_LIST_ITEM__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.NUMBERED_LIST_ITEM__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberedListItemAccess().getItemSTRINGTerminalRuleCall_1_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Presentation returns Presentation
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         theme=Theme? 
	 *         authors=Authors? 
	 *         institute=Institute? 
	 *         date=Date? 
	 *         (slides+=Slide | animations+=Animation)*
	 *     )
	 */
	protected void sequence_Presentation(ISerializationContext context, Presentation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Sec
	 *
	 * Constraint:
	 *     {Sec}
	 */
	protected void sequence_Section(ISerializationContext context, Sec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns Sec
	 *
	 * Constraint:
	 *     (name=STRING contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, Sec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns SubSec
	 *
	 * Constraint:
	 *     (name=STRING contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, SubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns SubSubSec
	 *
	 * Constraint:
	 *     (name=STRING contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, SubSubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSec
	 *
	 * Constraint:
	 *     {SubSec}
	 */
	protected void sequence_Section(ISerializationContext context, SubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSubSec
	 *
	 * Constraint:
	 *     {SubSubSec}
	 */
	protected void sequence_Section(ISerializationContext context, SubSubSec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Size returns Size
	 *
	 * Constraint:
	 *     scale=INT
	 */
	protected void sequence_Size(ISerializationContext context, Size semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.SIZE__SCALE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.SIZE__SCALE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeAccess().getScaleINTTerminalRuleCall_1_0(), semanticObject.getScale());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns Slide
	 *
	 * Constraint:
	 *     (name=STRING? contents+=Content+)
	 */
	protected void sequence_Slide(ISerializationContext context, Slide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (values+=STRING values+=STRING*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Table
	 *     Float returns Table
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (name=ID rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Block
	 *     Text returns Block
	 *
	 * Constraint:
	 *     (name=STRING? text=STRING)
	 */
	protected void sequence_Text(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Paragraph
	 *     Text returns Paragraph
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Text(ISerializationContext context, Paragraph semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextAccess().getTextSTRINGTerminalRuleCall_0_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Theme returns Theme
	 *
	 * Constraint:
	 *     (theme=BeamerTheme themeColor=ThemeColor?)
	 */
	protected void sequence_Theme(ISerializationContext context, Theme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnNumberedListItem returns UnNumberedListItem
	 *
	 * Constraint:
	 *     item=STRING
	 */
	protected void sequence_UnNumberedListItem(ISerializationContext context, UnNumberedListItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.UN_NUMBERED_LIST_ITEM__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.UN_NUMBERED_LIST_ITEM__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnNumberedListItemAccess().getItemSTRINGTerminalRuleCall_1_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
}
