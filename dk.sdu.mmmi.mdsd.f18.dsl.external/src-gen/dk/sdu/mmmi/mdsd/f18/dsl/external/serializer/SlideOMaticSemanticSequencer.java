/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.f18.dsl.external.services.SlideOMaticGrammarAccess;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Author;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Jump;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.List;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Model;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Move;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedListItem;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Paragraph;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Presentation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Section;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Size;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SlideOMaticPackage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSection;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSubSection;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TOC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Table;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TableRow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Theme;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.UnNumberedList;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SlideOMaticSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SlideOMaticGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SlideOMaticPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SlideOMaticPackage.ANIMATION:
				sequence_Animation(context, (Animation) semanticObject); 
				return; 
			case SlideOMaticPackage.AUTHOR:
				sequence_Author(context, (Author) semanticObject); 
				return; 
			case SlideOMaticPackage.BLOCK:
				sequence_Text(context, (Block) semanticObject); 
				return; 
			case SlideOMaticPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case SlideOMaticPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case SlideOMaticPackage.JUMP:
				sequence_AnimationType(context, (Jump) semanticObject); 
				return; 
			case SlideOMaticPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case SlideOMaticPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SlideOMaticPackage.MOVE:
				sequence_AnimationType(context, (Move) semanticObject); 
				return; 
			case SlideOMaticPackage.NUMBERED_LIST_ITEM:
				sequence_NumberedListItem(context, (NumberedListItem) semanticObject); 
				return; 
			case SlideOMaticPackage.PARAGRAPH:
				sequence_Text(context, (Paragraph) semanticObject); 
				return; 
			case SlideOMaticPackage.PRESENTATION:
				sequence_Presentation(context, (Presentation) semanticObject); 
				return; 
			case SlideOMaticPackage.SECTION:
				if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (Section) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (Section) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.SIZE:
				sequence_Size(context, (Size) semanticObject); 
				return; 
			case SlideOMaticPackage.SLIDE:
				sequence_Slide(context, (Slide) semanticObject); 
				return; 
			case SlideOMaticPackage.SUB_SECTION:
				if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (SubSection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (SubSection) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.SUB_SUB_SECTION:
				if (rule == grammarAccess.getSlideRule()) {
					sequence_Section_Slide(context, (SubSubSection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSectionRule()) {
					sequence_Section(context, (SubSubSection) semanticObject); 
					return; 
				}
				else break;
			case SlideOMaticPackage.TOC:
				sequence_Content(context, (TOC) semanticObject); 
				return; 
			case SlideOMaticPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case SlideOMaticPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case SlideOMaticPackage.THEME:
				sequence_Theme(context, (Theme) semanticObject); 
				return; 
			case SlideOMaticPackage.UN_NUMBERED_LIST:
				sequence_UnNumberedList(context, (UnNumberedList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnimationType returns Jump
	 *
	 * Constraint:
	 *     {Jump}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Jump semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnimationType returns Move
	 *
	 * Constraint:
	 *     {Move}
	 */
	protected void sequence_AnimationType(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Animation returns Animation
	 *
	 * Constraint:
	 *     (target=[Float|ID] type=AnimationType location=Alignment size=Size?)
	 */
	protected void sequence_Animation(ISerializationContext context, Animation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Setting returns Author
	 *     Author returns Author
	 *
	 * Constraint:
	 *     aName=STRING
	 */
	protected void sequence_Author(ISerializationContext context, Author semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.AUTHOR__ANAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.AUTHOR__ANAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAuthorAccess().getANameSTRINGTerminalRuleCall_1_0(), semanticObject.getAName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Content returns TOC
	 *
	 * Constraint:
	 *     {TOC}
	 */
	protected void sequence_Content(ISerializationContext context, TOC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Setting returns Date
	 *     Date returns Date
	 *
	 * Constraint:
	 *     date=STRING
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.DATE__DATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.DATE__DATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateAccess().getDateSTRINGTerminalRuleCall_1_0(), semanticObject.getDate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Image
	 *     Float returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     (name=ID src=STRING alignment=Alignment? size=Size)
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     (ListItems+=NumberedListItem+ | ListItems+=UnNumberedList+)
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     presentation=Presentation
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.MODEL__PRESENTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.MODEL__PRESENTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getPresentationPresentationParserRuleCall_0(), semanticObject.getPresentation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumberedListItem returns NumberedListItem
	 *
	 * Constraint:
	 *     item=STRING
	 */
	protected void sequence_NumberedListItem(ISerializationContext context, NumberedListItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.NUMBERED_LIST_ITEM__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.NUMBERED_LIST_ITEM__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberedListItemAccess().getItemSTRINGTerminalRuleCall_1_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Presentation returns Presentation
	 *
	 * Constraint:
	 *     (name=ID settings+=Setting* (slides+=Slide | animations+=Animation)*)
	 */
	protected void sequence_Presentation(ISerializationContext context, Presentation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     {Section}
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns Section
	 *
	 * Constraint:
	 *     (sName=STRING? contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns SubSection
	 *
	 * Constraint:
	 *     (sName=STRING? contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, SubSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns SubSubSection
	 *
	 * Constraint:
	 *     (sName=STRING? contents+=Content+)
	 */
	protected void sequence_Section_Slide(ISerializationContext context, SubSubSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSection
	 *
	 * Constraint:
	 *     {SubSection}
	 */
	protected void sequence_Section(ISerializationContext context, SubSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns SubSubSection
	 *
	 * Constraint:
	 *     {SubSubSection}
	 */
	protected void sequence_Section(ISerializationContext context, SubSubSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Size returns Size
	 *
	 * Constraint:
	 *     scale=INT
	 */
	protected void sequence_Size(ISerializationContext context, Size semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.SIZE__SCALE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.SIZE__SCALE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeAccess().getScaleINTTerminalRuleCall_1_0(), semanticObject.getScale());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Slide returns Slide
	 *
	 * Constraint:
	 *     (sName=STRING? contents+=Content+)
	 */
	protected void sequence_Slide(ISerializationContext context, Slide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (values+=STRING values+=STRING*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Table
	 *     Float returns Table
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (name=ID rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Block
	 *     Text returns Block
	 *
	 * Constraint:
	 *     (name=ID? text=STRING)
	 */
	protected void sequence_Text(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Content returns Paragraph
	 *     Text returns Paragraph
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Text(ISerializationContext context, Paragraph semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.TEXT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextAccess().getTextSTRINGTerminalRuleCall_0_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Setting returns Theme
	 *     Theme returns Theme
	 *
	 * Constraint:
	 *     (theme=BeamerTheme themeColor=ThemeColor?)
	 */
	protected void sequence_Theme(ISerializationContext context, Theme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnNumberedList returns UnNumberedList
	 *
	 * Constraint:
	 *     item=STRING
	 */
	protected void sequence_UnNumberedList(ISerializationContext context, UnNumberedList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SlideOMaticPackage.Literals.UN_NUMBERED_LIST__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SlideOMaticPackage.Literals.UN_NUMBERED_LIST__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnNumberedListAccess().getItemSTRINGTerminalRuleCall_1_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
}
