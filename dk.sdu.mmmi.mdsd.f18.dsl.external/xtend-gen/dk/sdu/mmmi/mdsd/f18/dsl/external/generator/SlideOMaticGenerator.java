/**
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.generator;

import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Authors;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Code;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CompileDate;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Content;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CurrentSecToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Div;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ExactSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Expression;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FileCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.InlineCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Institute;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Let;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.LineSequence;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.List;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ListItem;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.MathExp;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Minus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Mult;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Num;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Plus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Pow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Presentation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ProportionalSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Sec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Section;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Size;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Table;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TableRow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Text;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Theme;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Var;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Way;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Width;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SlideOMaticGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.doGenerateTexFile(Iterators.<Presentation>filter(resource.getAllContents(), Presentation.class).next(), fsa);
  }
  
  /**
   * Shitty workaround for danish letters in the generated source
   */
  public String dkLetters(final CharSequence cs) {
    String _xblockexpression = null;
    {
      final String str = cs.toString().replace("æ", "\\ae{}").replace("ø", "\\o{}").replace("å", "\\aa{}").replace("Æ", 
        "\\AE{}").replace("Ø", "\\O{}").replace("Å", "\\AA{}");
      _xblockexpression = str;
    }
    return _xblockexpression;
  }
  
  public void doGenerateTexFile(final Presentation p, final IFileSystemAccess2 fsa) {
    String _name = p.getName();
    String _plus = (_name + ".tex");
    fsa.generateFile(_plus, this.dkLetters(this.generateTexCode(p)));
  }
  
  public CharSequence generateTexCode(final Presentation p) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\documentclass{beamer}");
    _builder.newLine();
    _builder.append("\\usepackage[utf8]{inputenc}");
    _builder.newLine();
    _builder.append("\\usepackage[absolute,overlay]{textpos}");
    _builder.newLine();
    _builder.append("\\usepackage{graphicx}");
    _builder.newLine();
    _builder.append("\\usepackage[english]{babel}");
    _builder.newLine();
    _builder.append("\\usepackage{lastpage}");
    _builder.newLine();
    _builder.append("\\usepackage{minted}");
    _builder.newLine();
    _builder.append("\\setminted{autogobble, fontsize=\\footnotesize, linenos}");
    _builder.newLine();
    _builder.append("\\usepackage{tabu}");
    _builder.newLine();
    _builder.append("\\usepackage{mathtools}");
    _builder.newLine();
    _builder.newLine();
    {
      Theme _theme = p.getTheme();
      boolean _tripleNotEquals = (_theme != null);
      if (_tripleNotEquals) {
        _builder.append("\\usetheme{");
        String _theme_1 = p.getTheme().getTheme();
        _builder.append(_theme_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
        {
          String _themeColor = p.getTheme().getThemeColor();
          boolean _tripleNotEquals_1 = (_themeColor != null);
          if (_tripleNotEquals_1) {
            _builder.append("\\usecolortheme{");
            String _themeColor_1 = p.getTheme().getThemeColor();
            _builder.append(_themeColor_1);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.newLine();
    _builder.append("\\title{");
    String _name = p.getName();
    _builder.append(_name);
    _builder.append("}");
    _builder.newLineIfNotEmpty();
    {
      String _subtitle = p.getSubtitle();
      boolean _tripleNotEquals_2 = (_subtitle != null);
      if (_tripleNotEquals_2) {
        _builder.append("\\subtitle{");
        String _subtitle_1 = p.getSubtitle();
        _builder.append(_subtitle_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Authors _authors = p.getAuthors();
      boolean _tripleNotEquals_3 = (_authors != null);
      if (_tripleNotEquals_3) {
        _builder.append("\\author{");
        {
          Iterable<String> _filter = Iterables.<String>filter(p.getAuthors().getNames(), String.class);
          boolean _hasElements = false;
          for(final String a : _filter) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(" \\and ", "");
            }
            _builder.append(a);
          }
        }
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Institute _institute = p.getInstitute();
      boolean _tripleNotEquals_4 = (_institute != null);
      if (_tripleNotEquals_4) {
        _builder.append("\\institute{");
        String _name_1 = p.getInstitute().getName();
        _builder.append(_name_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Date _date = p.getDate();
      boolean _tripleNotEquals_5 = (_date != null);
      if (_tripleNotEquals_5) {
        {
          Date _date_1 = p.getDate();
          boolean _not = (!(_date_1 instanceof CompileDate));
          if (_not) {
            _builder.append("\\date{");
            String _date_2 = p.getDate().getDate();
            _builder.append(_date_2);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
      } else {
        _builder.append("\\date{");
        _builder.append(" ");
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("\\begin{document}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\\begin{frame}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\\titlepage");
    _builder.newLine();
    _builder.append("\\end{frame}");
    _builder.newLine();
    _builder.newLine();
    {
      Iterable<Slide> _filter_1 = Iterables.<Slide>filter(p.getSlides(), Slide.class);
      for(final Slide s : _filter_1) {
        CharSequence _generateSlideCode = this.generateSlideCode(s);
        _builder.append(_generateSlideCode);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("\\end{document}");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateSlideCode(final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Section _sec = s.getSec();
      boolean _tripleNotEquals = (_sec != null);
      if (_tripleNotEquals) {
        CharSequence _generateSectionsCode = this.generateSectionsCode(s.getSec(), s.getName());
        _builder.append(_generateSectionsCode);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\begin{frame}");
    {
      boolean _hasCode = this.hasCode(s);
      if (_hasCode) {
        _builder.append("[fragile]");
      }
    }
    {
      String _name = s.getName();
      boolean _tripleNotEquals_1 = (_name != null);
      if (_tripleNotEquals_1) {
        _builder.append("{");
        String _name_1 = s.getName();
        _builder.append(_name_1);
        _builder.append("}");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      EList<Content> _contents = s.getContents();
      for(final Content c : _contents) {
        CharSequence _generateContentsCode = this.generateContentsCode(c, s);
        _builder.append(_generateContentsCode);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\end{frame}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * used to generate sections
   */
  public CharSequence generateSectionsCode(final Section s, final String name) {
    String _switchResult = null;
    boolean _matched = false;
    if (s instanceof Sec) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\section{");
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (s instanceof SubSec) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\subsection{");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (s instanceof SubSubSec) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\subsubsection{");
        _switchResult = _builder.toString();
      }
    }
    String _plus = (_switchResult + name);
    return (_plus + "}");
  }
  
  public CharSequence generateContentsCode(final Content c, final Slide s) {
    String _switchResult = null;
    boolean _matched = false;
    if (c instanceof ToC) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\tableofcontents");
      {
        if ((c instanceof CurrentSecToC)) {
          _builder.append("[sections=\\value{section}]");
        } else {
          _builder.append("[hideallsubsections]");
        }
      }
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (c instanceof Text) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("{");
        String _text = ((Text)c).getText();
        _builder.append(_text);
        _builder.append("}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof Block) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\begin{block}");
        {
          String _name = ((Block)c).getName();
          boolean _tripleNotEquals = (_name != null);
          if (_tripleNotEquals) {
            _builder.append("{");
            String _name_1 = ((Block)c).getName();
            _builder.append(_name_1);
            _builder.append("}");
          }
        }
        _builder.newLineIfNotEmpty();
        {
          EList<Content> _content = ((Block)c).getContent();
          for(final Content bc : _content) {
            CharSequence _generateContentsCode = this.generateContentsCode(bc, s);
            _builder.append(_generateContentsCode);
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\\end{block}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof List) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\begin{");
        {
          if ((c instanceof NumberedList)) {
            _builder.append("enumerate");
          } else {
            _builder.append("itemize");
          }
        }
        _builder.append("}");
        _builder.newLineIfNotEmpty();
        {
          EList<ListItem> _items = ((List)c).getItems();
          for(final ListItem i : _items) {
            _builder.append("\\item ");
            String _item = i.getItem();
            _builder.append(_item);
            {
              List _nestedList = i.getNestedList();
              boolean _tripleNotEquals = (_nestedList != null);
              if (_tripleNotEquals) {
                CharSequence _generateContentsCode = this.generateContentsCode(i.getNestedList(), s);
                _builder.append(_generateContentsCode);
              }
            }
            {
              String _click = i.getClick();
              boolean _tripleNotEquals_1 = (_click != null);
              if (_tripleNotEquals_1) {
                _builder.append("\\pause");
              }
            }
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\\end{");
        {
          if ((c instanceof NumberedList)) {
            _builder.append("enumerate");
          } else {
            _builder.append("itemize");
          }
        }
        _builder.append("}");
        _builder.newLineIfNotEmpty();
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof Image) {
        _matched=true;
        String _xblockexpression = null;
        {
          final String src = ((Image)c).getSrc().replace("\\", "/");
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("\\begin{center}");
          _builder.newLine();
          _builder.append("\\includegraphics[");
          CharSequence _string = this.getString(((Image)c).getSize());
          _builder.append(_string);
          _builder.append("]{");
          _builder.append(src);
          _builder.append("}");
          _builder.newLineIfNotEmpty();
          _builder.append("\\end{center}");
          _builder.newLine();
          _xblockexpression = _builder.toString();
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (c instanceof Table) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\begin{tabular}{");
        {
          EList<TableRow> _rows = ((Table)c).getRows();
          for(final TableRow i : _rows) {
            _builder.append("|c");
          }
        }
        _builder.append("|}");
        _builder.newLineIfNotEmpty();
        _builder.append("\\hline");
        _builder.newLine();
        {
          EList<TableRow> _rows_1 = ((Table)c).getRows();
          for(final TableRow row : _rows_1) {
            {
              EList<String> _values = row.getValues();
              boolean _hasElements = false;
              for(final String v : _values) {
                if (!_hasElements) {
                  _hasElements = true;
                } else {
                  _builder.appendImmediate(" & ", "");
                }
                _builder.append(v);
              }
            }
            _builder.append(" \\\\ \\hline");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\\end{tabular}");
        _builder.newLine();
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof InlineCode) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\begin{minted}{");
        String _lang = ((InlineCode)c).getLang();
        _builder.append(_lang);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
        String _code = ((InlineCode)c).getCode();
        _builder.append(_code);
        _builder.newLineIfNotEmpty();
        _builder.append("\\end{minted}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof FileCode) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        {
          int _length = ((Object[])Conversions.unwrapArray(((FileCode)c).getLines(), Object.class)).length;
          boolean _greaterThan = (_length > 0);
          if (_greaterThan) {
            int i = 0;
            _builder.newLineIfNotEmpty();
            {
              EList<LineSequence> _lines = ((FileCode)c).getLines();
              for(final LineSequence l : _lines) {
                {
                  int _plusPlus = i++;
                  boolean _greaterThan_1 = (_plusPlus > 0);
                  if (_greaterThan_1) {
                    _builder.append("\\begin{frame}[fragile]{");
                    String _name = s.getName();
                    _builder.append(_name);
                    _builder.append("}");
                    _builder.newLineIfNotEmpty();
                  }
                }
                _builder.append("\\begin{minted}{");
                String _lang = ((FileCode)c).getLang();
                _builder.append(_lang);
                _builder.append("}");
                _builder.newLineIfNotEmpty();
                _builder.append("\t");
                _builder.append("// hej ");
                _builder.append(i, "\t");
                _builder.newLineIfNotEmpty();
                _builder.append("\\end{minted}");
                _builder.newLine();
                {
                  int _length_1 = ((Object[])Conversions.unwrapArray(((FileCode)c).getLines(), Object.class)).length;
                  boolean _lessThan = (i < _length_1);
                  if (_lessThan) {
                    _builder.append("\\end{frame}");
                    _builder.newLine();
                  }
                }
              }
            }
          } else {
            _builder.append("\\inputminted{");
            String _lang_1 = ((FileCode)c).getLang();
            _builder.append(_lang_1);
            _builder.append("}{");
            String _src = ((FileCode)c).getSrc();
            _builder.append(_src);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (c instanceof MathExp) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\begin{equation}");
        _builder.newLine();
        String _display = this.display(((MathExp)c));
        _builder.append(_display);
        _builder.append(" ");
        {
          String _eval = ((MathExp)c).getEval();
          boolean _tripleNotEquals = (_eval != null);
          if (_tripleNotEquals) {
            _builder.append("=");
            int _compute = this.compute(((MathExp)c));
            _builder.append(_compute);
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append("\\end{equation}");
        _builder.newLine();
        _switchResult = _builder.toString();
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    {
      String _click = c.getClick();
      boolean _tripleNotEquals = (_click != null);
      if (_tripleNotEquals) {
        _builder.append("\\pause");
      }
    }
    return (_switchResult + _builder);
  }
  
  /**
   * Function to convert the size of floats into the correct LaTeX string.
   */
  public CharSequence getString(final Size s) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (s instanceof ProportionalSize) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      {
        Way _way = ((ProportionalSize)s).getWay();
        if ((_way instanceof Width)) {
          _builder.append("width=");
          int _scale = ((ProportionalSize)s).getScale();
          float _divide = (_scale / 100f);
          _builder.append(_divide);
          _builder.append("\\textwidth");
        } else {
          _builder.append("height=");
          int _scale_1 = ((ProportionalSize)s).getScale();
          float _divide_1 = (_scale_1 / 100f);
          _builder.append(_divide_1);
          _builder.append("\\textheight");
        }
      }
      _switchResult = _builder;
    }
    if (!_matched) {
      if (s instanceof ExactSize) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        int _size = ((ExactSize)s).getSize();
        _builder.append(_size);
        String _unit = ((ExactSize)s).getUnit();
        _builder.append(_unit);
        _switchResult = _builder;
      }
    }
    return _switchResult;
  }
  
  /**
   * Function to check if the slide contains code
   * used to add the "[fragile]" to the slide, in order to support minted.
   */
  public boolean hasCode(final Slide s) {
    EList<Content> _contents = s.getContents();
    for (final Content c : _contents) {
      if ((c instanceof Code)) {
        return true;
      }
    }
    return false;
  }
  
  public Map<String, Integer> bind(final Map<String, Integer> env1, final String name, final int value) {
    HashMap<String, Integer> _xblockexpression = null;
    {
      final HashMap<String, Integer> env2 = new HashMap<String, Integer>(env1);
      env2.put(name, Integer.valueOf(value));
      _xblockexpression = env2;
    }
    return _xblockexpression;
  }
  
  public int compute(final MathExp math) {
    Expression _exp = math.getExp();
    HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
    return this.computeExp(_exp, _hashMap);
  }
  
  public int computeExp(final Expression exp, final Map<String, Integer> env) {
    Integer _switchResult = null;
    boolean _matched = false;
    if (exp instanceof Plus) {
      _matched=true;
      int _computeExp = this.computeExp(((Plus)exp).getLeft(), env);
      int _computeExp_1 = this.computeExp(((Plus)exp).getRight(), env);
      _switchResult = Integer.valueOf((_computeExp + _computeExp_1));
    }
    if (!_matched) {
      if (exp instanceof Minus) {
        _matched=true;
        int _computeExp = this.computeExp(((Minus)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Minus)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp - _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Mult) {
        _matched=true;
        int _computeExp = this.computeExp(((Mult)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Mult)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp * _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Div) {
        _matched=true;
        int _computeExp = this.computeExp(((Div)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Div)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp / _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Num) {
        _matched=true;
        _switchResult = Integer.valueOf(((Num)exp).getValue());
      }
    }
    if (!_matched) {
      if (exp instanceof Var) {
        _matched=true;
        _switchResult = env.get(((Var)exp).getId());
      }
    }
    if (!_matched) {
      if (exp instanceof Let) {
        _matched=true;
        _switchResult = Integer.valueOf(this.computeExp(((Let)exp).getBody(), this.bind(env, ((Let)exp).getId(), this.computeExp(((Let)exp).getBinding(), env))));
      }
    }
    if (!_matched) {
      if (exp instanceof Pow) {
        _matched=true;
        double _pow = Math.pow(this.computeExp(((Pow)exp).getLeft(), env), this.computeExp(((Pow)exp).getRight(), env));
        _switchResult = Integer.valueOf(((int) _pow));
      }
    }
    if (!_matched) {
      throw new Error("Invalid expression");
    }
    return (_switchResult).intValue();
  }
  
  public String display(final MathExp math) {
    return this.displayExp(math.getExp());
  }
  
  public String displayExp(final Expression exp) {
    String _switchResult = null;
    boolean _matched = false;
    if (exp instanceof Plus) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      String _displayExp = this.displayExp(((Plus)exp).getLeft());
      _builder.append(_displayExp);
      _builder.append("+");
      String _displayExp_1 = this.displayExp(((Plus)exp).getRight());
      _builder.append(_displayExp_1);
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (exp instanceof Minus) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Minus)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("-");
        String _displayExp_1 = this.displayExp(((Minus)exp).getRight());
        _builder.append(_displayExp_1);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Mult) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Mult)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("\\cdot");
        String _displayExp_1 = this.displayExp(((Mult)exp).getRight());
        _builder.append(_displayExp_1);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Div) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\frac{");
        String _displayExp = this.displayExp(((Div)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("}{");
        String _displayExp_1 = this.displayExp(((Div)exp).getRight());
        _builder.append(_displayExp_1);
        _builder.append("}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Num) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _string = Integer.toString(((Num)exp).getValue());
        _builder.append(_string);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Var) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _id = ((Var)exp).getId();
        _builder.append(_id);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Let) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("let ");
        String _id = ((Let)exp).getId();
        _builder.append(_id);
        _builder.append(" = ");
        String _displayExp = this.displayExp(((Let)exp).getBinding());
        _builder.append(_displayExp);
        _builder.append(" in ");
        String _displayExp_1 = this.displayExp(((Let)exp).getBody());
        _builder.append(_displayExp_1);
        _builder.append(" end");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Pow) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Pow)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("^{");
        String _displayExp_1 = this.displayExp(((Pow)exp).getRight());
        _builder.append(_displayExp_1);
        _builder.append("}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      throw new Error("Invalid expression");
    }
    return _switchResult;
  }
}
