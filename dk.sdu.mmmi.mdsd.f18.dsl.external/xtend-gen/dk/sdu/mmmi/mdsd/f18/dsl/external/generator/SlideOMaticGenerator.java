/**
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.generator;

import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Authors;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Bold;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Code;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CompileDate;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Content;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CurrentSecToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Div;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ExactSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Expression;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FileCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FootNote;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.InlineCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Institute;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Italic;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Let;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.LineSequence;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.List;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ListItem;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.MathExp;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Minus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Mult;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Num;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.NumberedList;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Plus;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Pow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Presentation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ProportionalSize;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Sec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Section;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ShowImage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Size;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SubSubSec;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Table;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TableRow;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Text;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TextType;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Theme;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.ToC;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.URL;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Underline;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Var;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Way;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Width;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SlideOMaticGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.doGenerateTexFile(Iterators.<Presentation>filter(resource.getAllContents(), Presentation.class).next(), fsa);
  }
  
  /**
   * Shitty workaround for danish letters in the generated source
   */
  public String dkLetters(final CharSequence cs) {
    String _xblockexpression = null;
    {
      final String str = cs.toString().replace("æ", "\\ae{}").replace("ø", "\\o{}").replace("å", "\\aa{}").replace("Æ", 
        "\\AE{}").replace("Ø", "\\O{}").replace("Å", "\\AA{}");
      _xblockexpression = str;
    }
    return _xblockexpression;
  }
  
  /**
   * Function to generate the .tex file
   * Could also be used for calling the system pdfLaTeX function, in order to generate a pdf file in stead
   */
  public void doGenerateTexFile(final Presentation p, final IFileSystemAccess2 fsa) {
    String _name = p.getName();
    String _plus = (_name + "/");
    String _name_1 = p.getName();
    String _plus_1 = (_plus + _name_1);
    String _plus_2 = (_plus_1 + ".tex");
    fsa.generateFile(_plus_2, this.dkLetters(this.generateTexCode(p)));
  }
  
  /**
   * Creates the main .tex file string
   */
  public CharSequence generateTexCode(final Presentation p) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\documentclass{beamer}");
    _builder.newLine();
    _builder.append("\\usepackage[utf8]{inputenc}");
    _builder.newLine();
    _builder.append("\\usepackage[absolute,overlay]{textpos}");
    _builder.newLine();
    _builder.append("\\usepackage{graphicx}");
    _builder.newLine();
    _builder.append("\\usepackage[english]{babel}");
    _builder.newLine();
    _builder.append("\\usepackage{lastpage}");
    _builder.newLine();
    _builder.append("\\usepackage{minted}");
    _builder.newLine();
    _builder.append("\\setminted{autogobble, fontsize=\\footnotesize, linenos}");
    _builder.newLine();
    _builder.append("\\usepackage{tabu}");
    _builder.newLine();
    _builder.append("\\usepackage{mathtools}");
    _builder.newLine();
    _builder.append("\\usepackage[export]{adjustbox}");
    _builder.newLine();
    _builder.newLine();
    {
      Theme _theme = p.getTheme();
      boolean _tripleNotEquals = (_theme != null);
      if (_tripleNotEquals) {
        _builder.append("\\usetheme{");
        String _theme_1 = p.getTheme().getTheme();
        _builder.append(_theme_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
        {
          String _themeColor = p.getTheme().getThemeColor();
          boolean _tripleNotEquals_1 = (_themeColor != null);
          if (_tripleNotEquals_1) {
            _builder.append("\\usecolortheme{");
            String _themeColor_1 = p.getTheme().getThemeColor();
            _builder.append(_themeColor_1);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.newLine();
    _builder.append("\\title{");
    String _name = p.getName();
    _builder.append(_name);
    _builder.append("}");
    _builder.newLineIfNotEmpty();
    {
      String _subtitle = p.getSubtitle();
      boolean _tripleNotEquals_2 = (_subtitle != null);
      if (_tripleNotEquals_2) {
        _builder.append("\\subtitle{");
        String _subtitle_1 = p.getSubtitle();
        _builder.append(_subtitle_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Authors _authors = p.getAuthors();
      boolean _tripleNotEquals_3 = (_authors != null);
      if (_tripleNotEquals_3) {
        _builder.append("\\author{");
        {
          Iterable<String> _filter = Iterables.<String>filter(p.getAuthors().getNames(), String.class);
          boolean _hasElements = false;
          for(final String a : _filter) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(" \\and ", "");
            }
            _builder.append(a);
          }
        }
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Institute _institute = p.getInstitute();
      boolean _tripleNotEquals_4 = (_institute != null);
      if (_tripleNotEquals_4) {
        _builder.append("\\institute{");
        String _name_1 = p.getInstitute().getName();
        _builder.append(_name_1);
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      Date _date = p.getDate();
      boolean _tripleNotEquals_5 = (_date != null);
      if (_tripleNotEquals_5) {
        {
          Date _date_1 = p.getDate();
          boolean _not = (!(_date_1 instanceof CompileDate));
          if (_not) {
            _builder.append("\\date{");
            String _date_2 = p.getDate().getDate();
            _builder.append(_date_2);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
      } else {
        _builder.append("\\date{");
        _builder.append(" ");
        _builder.append("}");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("\\begin{document}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\\begin{frame}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\\titlepage");
    _builder.newLine();
    _builder.append("\\end{frame}");
    _builder.newLine();
    _builder.newLine();
    {
      Iterable<Slide> _filter_1 = Iterables.<Slide>filter(p.getSlides(), Slide.class);
      for(final Slide s : _filter_1) {
        CharSequence _generateSlideCode = this.generateSlideCode(s);
        _builder.append(_generateSlideCode);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("\\end{document}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * Creates creates the latex code for slides
   * if the frame (slide) contains code, it needsd to have the 'fragile' attribute, thats why there is an if check.
   */
  public CharSequence generateSlideCode(final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Section _sec = s.getSec();
      boolean _tripleNotEquals = (_sec != null);
      if (_tripleNotEquals) {
        CharSequence _generateSectionsCode = this.generateSectionsCode(s.getSec(), s.getName());
        _builder.append(_generateSectionsCode);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\begin{frame}");
    {
      boolean _hasCode = this.hasCode(s);
      if (_hasCode) {
        _builder.append("[fragile]");
      }
    }
    {
      String _name = s.getName();
      boolean _tripleNotEquals_1 = (_name != null);
      if (_tripleNotEquals_1) {
        _builder.append("{");
        String _name_1 = s.getName();
        _builder.append(_name_1);
        _builder.append("}");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      EList<Content> _contents = s.getContents();
      for(final Content c : _contents) {
        CharSequence _generateContents = this.generateContents(c, s);
        _builder.append(_generateContents);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\end{frame}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * used to generate sections
   */
  public CharSequence generateSectionsCode(final Section s, final String name) {
    String _switchResult = null;
    boolean _matched = false;
    if (s instanceof Sec) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\section{");
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (s instanceof SubSec) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\subsection{");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (s instanceof SubSubSec) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\subsubsection{");
        _switchResult = _builder.toString();
      }
    }
    String _plus = (_switchResult + name);
    return (_plus + "}");
  }
  
  /**
   * generates content code, calls the dispatch methods, and appends a '\pause' if needed.
   */
  public CharSequence generateContents(final Content c, final Slide s) {
    CharSequence _generateContentsCode = this.generateContentsCode(c, s);
    StringConcatenation _builder = new StringConcatenation();
    {
      String _click = c.getClick();
      boolean _tripleNotEquals = (_click != null);
      if (_tripleNotEquals) {
        _builder.append("\\pause");
      }
    }
    return (_generateContentsCode + _builder.toString());
  }
  
  /**
   * dispatch method for creating Table of Contents code
   */
  protected CharSequence _generateContentsCode(final ToC t, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\tableofcontents");
    {
      if ((t instanceof CurrentSecToC)) {
        _builder.append("[sections=\\value{section}]");
      } else {
        _builder.append("[hideallsubsections]");
      }
    }
    return _builder;
  }
  
  /**
   * dispatch method for creating text code
   */
  protected CharSequence _generateContentsCode(final Text t, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<TextType> _types = t.getTypes();
      for(final TextType tt : _types) {
        CharSequence _generateTextTypeStartCode = this.generateTextTypeStartCode(tt);
        _builder.append(_generateTextTypeStartCode);
      }
    }
    String _sanitize = this.sanitize(t.getText());
    _builder.append(_sanitize);
    {
      EList<TextType> _types_1 = t.getTypes();
      for(final TextType tt_1 : _types_1) {
        _builder.append("}");
      }
    }
    return _builder;
  }
  
  /**
   * Helper function for creating the texttype code
   */
  public CharSequence generateTextTypeStartCode(final TextType tt) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\");
    {
      if ((tt instanceof Bold)) {
        _builder.append("textbf");
      } else {
        if ((tt instanceof Italic)) {
          _builder.append("textit");
        } else {
          if ((tt instanceof Underline)) {
            _builder.append("underline");
          } else {
            if ((tt instanceof FootNote)) {
              _builder.append("footnote");
            } else {
              if ((tt instanceof URL)) {
                _builder.append("url");
              }
            }
          }
        }
      }
    }
    _builder.append("{");
    return _builder;
  }
  
  /**
   * Some common characters, which needs to be sanitized in latex, in strings...
   */
  public String sanitize(final String str) {
    return str.replaceAll("#", "\\#").replaceAll("&", "\\&").replaceAll("%", "\\%").replaceAll("_", "\\_");
  }
  
  /**
   * dispatch function to create block code, recursive call to generateContents, for the contents of the block
   */
  protected CharSequence _generateContentsCode(final Block b, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\begin{block}");
    {
      String _name = b.getName();
      boolean _tripleNotEquals = (_name != null);
      if (_tripleNotEquals) {
        _builder.append("{");
        String _name_1 = b.getName();
        _builder.append(_name_1);
        _builder.append("}");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      EList<Content> _content = b.getContent();
      for(final Content bc : _content) {
        CharSequence _generateContents = this.generateContents(bc, s);
        _builder.append(_generateContents);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\end{block}");
    return _builder;
  }
  
  /**
   * dispatch function to create lists code, either numbered or unnumbered lists.
   */
  protected CharSequence _generateContentsCode(final List l, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\begin{");
    {
      if ((l instanceof NumberedList)) {
        _builder.append("enumerate");
      } else {
        _builder.append("itemize");
      }
    }
    _builder.append("}");
    _builder.newLineIfNotEmpty();
    {
      EList<ListItem> _items = l.getItems();
      for(final ListItem i : _items) {
        _builder.append("\\item ");
        String _item = i.getItem();
        _builder.append(_item);
        {
          List _nestedList = i.getNestedList();
          boolean _tripleNotEquals = (_nestedList != null);
          if (_tripleNotEquals) {
            CharSequence _generateContentsCode = this.generateContentsCode(i.getNestedList(), s);
            _builder.append(_generateContentsCode);
          }
        }
        {
          String _click = i.getClick();
          boolean _tripleNotEquals_1 = (_click != null);
          if (_tripleNotEquals_1) {
            _builder.append("\\pause");
          }
        }
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\end{");
    {
      if ((l instanceof NumberedList)) {
        _builder.append("enumerate");
      } else {
        _builder.append("itemize");
      }
    }
    _builder.append("}");
    return _builder;
  }
  
  /**
   * Method for generating animation code
   */
  protected CharSequence _generateContentsCode(final Animation a, final Slide s) {
    CharSequence _xblockexpression = null;
    {
      final String from = a.getFromLocation();
      final String final_ = a.getFinalLocation();
      final String via = a.getViaLocation();
      final Image target = a.getTarget();
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\only<1> {");
      CharSequence _generateAnimationImageCode = this.generateAnimationImageCode(target, from);
      _builder.append(_generateAnimationImageCode);
      _builder.append("}");
      _builder.newLineIfNotEmpty();
      {
        String _viaLocation = a.getViaLocation();
        boolean _tripleNotEquals = (_viaLocation != null);
        if (_tripleNotEquals) {
          _builder.append("\\only<2> {");
          CharSequence _generateAnimationImageCode_1 = this.generateAnimationImageCode(target, via);
          _builder.append(_generateAnimationImageCode_1);
          _builder.append("}");
          _builder.newLineIfNotEmpty();
          _builder.append("\\only<3> {");
          CharSequence _generateAnimationImageCode_2 = this.generateAnimationImageCode(target, final_);
          _builder.append(_generateAnimationImageCode_2);
          _builder.append("}");
          _builder.newLineIfNotEmpty();
        } else {
          _builder.append("\\only<2> {");
          CharSequence _generateAnimationImageCode_3 = this.generateAnimationImageCode(target, final_);
          _builder.append(_generateAnimationImageCode_3);
          _builder.append("}");
          _builder.newLineIfNotEmpty();
        }
      }
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence generateAnimationImageCode(final Image i, final String alignment) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\includegraphics[");
    CharSequence _string = this.getString(i.getSize());
    _builder.append(_string);
    _builder.newLineIfNotEmpty();
    {
      int _angle = i.getAngle();
      boolean _tripleNotEquals = (_angle != 0);
      if (_tripleNotEquals) {
        _builder.append(", angle=");
        int _angle_1 = i.getAngle();
        _builder.append(_angle_1);
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append(", ");
    _builder.append(alignment);
    _builder.append("]{");
    String _src = i.getSrc();
    _builder.append(_src);
    _builder.append("}");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * Enables you to present an image based on a reference
   */
  protected CharSequence _generateContentsCode(final ShowImage i, final Slide s) {
    CharSequence _xblockexpression = null;
    {
      final Image img = i.getImage();
      _xblockexpression = this.generateContentsCode(img, s);
    }
    return _xblockexpression;
  }
  
  /**
   * Dispatch function to create image code,
   */
  protected CharSequence _generateContentsCode(final Image i, final Slide s) {
    CharSequence _xblockexpression = null;
    {
      final String src = i.getSrc().replace("\\", "/");
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\begin{figure}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("\\includegraphics[");
      CharSequence _string = this.getString(i.getSize());
      _builder.append(_string, "\t");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      {
        int _angle = i.getAngle();
        boolean _tripleNotEquals = (_angle != 0);
        if (_tripleNotEquals) {
          _builder.append(", angle=");
          int _angle_1 = i.getAngle();
          _builder.append(_angle_1, "\t");
        }
      }
      _builder.append(",");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      {
        String _alignment = i.getAlignment();
        boolean _tripleEquals = (_alignment == null);
        if (_tripleEquals) {
          _builder.append(" center");
        } else {
          _builder.append(" ");
          String _alignment_1 = i.getAlignment();
          _builder.append(_alignment_1, "\t");
        }
      }
      _builder.append("]{");
      _builder.append(src, "\t");
      _builder.append("}");
      _builder.newLineIfNotEmpty();
      _builder.append("\\end{figure}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  /**
   * Function to convert the size of floats into the correct LaTeX string.
   */
  public CharSequence getString(final Size s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Way _way = s.getWay();
      if ((_way instanceof Width)) {
        _builder.append("width=");
      } else {
        _builder.append("height=");
      }
    }
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (s instanceof ProportionalSize) {
      _matched=true;
      StringConcatenation _builder_1 = new StringConcatenation();
      {
        Way _way_1 = ((ProportionalSize)s).getWay();
        if ((_way_1 instanceof Width)) {
          int _scale = ((ProportionalSize)s).getScale();
          float _divide = (_scale / 100f);
          _builder_1.append(_divide);
          _builder_1.append("\\textwidth");
        } else {
          int _scale_1 = ((ProportionalSize)s).getScale();
          float _divide_1 = (_scale_1 / 100f);
          _builder_1.append(_divide_1);
          _builder_1.append("\\textheight");
        }
      }
      _switchResult = _builder_1;
    }
    if (!_matched) {
      if (s instanceof ExactSize) {
        _matched=true;
        StringConcatenation _builder_1 = new StringConcatenation();
        int _size = ((ExactSize)s).getSize();
        _builder_1.append(_size);
        String _unit = ((ExactSize)s).getUnit();
        _builder_1.append(_unit);
        _switchResult = _builder_1;
      }
    }
    return (_builder.toString() + _switchResult);
  }
  
  /**
   * dispatch function to create table code, it is only possible to create
   */
  protected CharSequence _generateContentsCode(final Table t, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\begin{tabular}{");
    {
      EList<TableRow> _rows = t.getRows();
      for(final TableRow i : _rows) {
        _builder.append("|c");
      }
    }
    _builder.append("|}");
    _builder.newLineIfNotEmpty();
    _builder.append("\\hline");
    _builder.newLine();
    {
      EList<TableRow> _rows_1 = t.getRows();
      for(final TableRow row : _rows_1) {
        {
          EList<String> _values = row.getValues();
          boolean _hasElements = false;
          for(final String v : _values) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(" & ", "");
            }
            _builder.append(v);
          }
        }
        _builder.append(" \\\\ \\hline");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\\end{tabular}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * dispatch function to create LaTeX code for codehighlighting, using minted.
   * it
   */
  protected CharSequence _generateContentsCode(final Code c, final Slide s) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (c instanceof InlineCode) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("\\begin{minted}{");
      String _lang = ((InlineCode)c).getLang();
      _builder.append(_lang);
      _builder.append("}");
      _builder.newLineIfNotEmpty();
      String _code = ((InlineCode)c).getCode();
      _builder.append(_code);
      _builder.newLineIfNotEmpty();
      _builder.append("\\end{minted}");
      _switchResult = _builder;
    }
    if (!_matched) {
      if (c instanceof FileCode) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        {
          int _length = ((Object[])Conversions.unwrapArray(((FileCode)c).getLines(), Object.class)).length;
          boolean _greaterThan = (_length > 0);
          if (_greaterThan) {
            int i = 0;
            _builder.newLineIfNotEmpty();
            {
              EList<LineSequence> _lines = ((FileCode)c).getLines();
              for(final LineSequence l : _lines) {
                {
                  int _plusPlus = i++;
                  boolean _greaterThan_1 = (_plusPlus > 0);
                  if (_greaterThan_1) {
                    _builder.append("\\begin{frame}[fragile]{");
                    String _name = s.getName();
                    _builder.append(_name);
                    _builder.append("}");
                    _builder.newLineIfNotEmpty();
                  }
                }
                _builder.newLine();
                _builder.append("\\begin{minted}{py}");
                _builder.newLine();
                _builder.append("print(\'The code line-by-line feature is not supported\')");
                _builder.newLine();
                _builder.append("\\end{minted}");
                _builder.newLine();
                {
                  int _length_1 = ((Object[])Conversions.unwrapArray(((FileCode)c).getLines(), Object.class)).length;
                  boolean _lessThan = (i < _length_1);
                  if (_lessThan) {
                    _builder.append("\\end{frame}");
                    _builder.newLine();
                  }
                }
              }
            }
          } else {
            _builder.append("\\inputminted{");
            String _lang = ((FileCode)c).getLang();
            _builder.append(_lang);
            _builder.append("}{");
            String _src = ((FileCode)c).getSrc();
            _builder.append(_src);
            _builder.append("}");
            _builder.newLineIfNotEmpty();
          }
        }
        _switchResult = _builder;
      }
    }
    return _switchResult;
  }
  
  /**
   * Function to check if the slide contains code
   * used to add the "[fragile]" to the slide, in order to support minted.
   */
  public boolean hasCode(final Slide s) {
    EList<Content> _contents = s.getContents();
    for (final Content c : _contents) {
      if ((c instanceof Code)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * dispatch function to create equations code
   */
  protected CharSequence _generateContentsCode(final MathExp m, final Slide s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\\begin{equation}");
    _builder.newLine();
    String _display = this.display(m);
    _builder.append(_display);
    _builder.append(" ");
    {
      String _eval = m.getEval();
      boolean _tripleNotEquals = (_eval != null);
      if (_tripleNotEquals) {
        _builder.append("=");
        int _compute = this.compute(m);
        _builder.append(_compute);
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("\\end{equation}");
    _builder.newLine();
    return _builder;
  }
  
  public Map<String, Integer> bind(final Map<String, Integer> env1, final String name, final int value) {
    HashMap<String, Integer> _xblockexpression = null;
    {
      final HashMap<String, Integer> env2 = new HashMap<String, Integer>(env1);
      env2.put(name, Integer.valueOf(value));
      _xblockexpression = env2;
    }
    return _xblockexpression;
  }
  
  /**
   * function for cumputing the overall equation
   */
  public int compute(final MathExp math) {
    Expression _exp = math.getExp();
    HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
    return this.computeExp(_exp, _hashMap);
  }
  
  /**
   * function for computing the actual math
   */
  public int computeExp(final Expression exp, final Map<String, Integer> env) {
    Integer _switchResult = null;
    boolean _matched = false;
    if (exp instanceof Plus) {
      _matched=true;
      int _computeExp = this.computeExp(((Plus)exp).getLeft(), env);
      int _computeExp_1 = this.computeExp(((Plus)exp).getRight(), env);
      _switchResult = Integer.valueOf((_computeExp + _computeExp_1));
    }
    if (!_matched) {
      if (exp instanceof Minus) {
        _matched=true;
        int _computeExp = this.computeExp(((Minus)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Minus)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp - _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Mult) {
        _matched=true;
        int _computeExp = this.computeExp(((Mult)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Mult)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp * _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Div) {
        _matched=true;
        int _computeExp = this.computeExp(((Div)exp).getLeft(), env);
        int _computeExp_1 = this.computeExp(((Div)exp).getRight(), env);
        _switchResult = Integer.valueOf((_computeExp / _computeExp_1));
      }
    }
    if (!_matched) {
      if (exp instanceof Num) {
        _matched=true;
        _switchResult = Integer.valueOf(((Num)exp).getValue());
      }
    }
    if (!_matched) {
      if (exp instanceof Var) {
        _matched=true;
        _switchResult = env.get(((Var)exp).getId());
      }
    }
    if (!_matched) {
      if (exp instanceof Let) {
        _matched=true;
        _switchResult = Integer.valueOf(this.computeExp(((Let)exp).getBody(), this.bind(env, ((Let)exp).getId(), this.computeExp(((Let)exp).getBinding(), env))));
      }
    }
    if (!_matched) {
      if (exp instanceof Pow) {
        _matched=true;
        double _pow = Math.pow(this.computeExp(((Pow)exp).getLeft(), env), this.computeExp(((Pow)exp).getRight(), env));
        _switchResult = Integer.valueOf(((int) _pow));
      }
    }
    if (!_matched) {
      throw new Error("Invalid expression");
    }
    return (_switchResult).intValue();
  }
  
  /**
   * function to show math
   */
  public String display(final MathExp math) {
    return this.displayExp(math.getExp());
  }
  
  /**
   * function to generate math symbols in latex
   */
  public String displayExp(final Expression exp) {
    String _switchResult = null;
    boolean _matched = false;
    if (exp instanceof Plus) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      String _displayExp = this.displayExp(((Plus)exp).getLeft());
      _builder.append(_displayExp);
      _builder.append("+");
      String _displayExp_1 = this.displayExp(((Plus)exp).getRight());
      _builder.append(_displayExp_1);
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (exp instanceof Minus) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Minus)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("-");
        String _displayExp_1 = this.displayExp(((Minus)exp).getRight());
        _builder.append(_displayExp_1);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Mult) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Mult)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("\\cdot");
        String _displayExp_1 = this.displayExp(((Mult)exp).getRight());
        _builder.append(_displayExp_1);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Div) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\\frac{");
        String _displayExp = this.displayExp(((Div)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("}{");
        String _displayExp_1 = this.displayExp(((Div)exp).getRight());
        _builder.append(_displayExp_1);
        _builder.append("}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Num) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _string = Integer.toString(((Num)exp).getValue());
        _builder.append(_string);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Var) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _id = ((Var)exp).getId();
        _builder.append(_id);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Let) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("let ");
        String _id = ((Let)exp).getId();
        _builder.append(_id);
        _builder.append(" = ");
        String _displayExp = this.displayExp(((Let)exp).getBinding());
        _builder.append(_displayExp);
        _builder.append(" in ");
        String _displayExp_1 = this.displayExp(((Let)exp).getBody());
        _builder.append(_displayExp_1);
        _builder.append(" end");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (exp instanceof Pow) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _displayExp = this.displayExp(((Pow)exp).getLeft());
        _builder.append(_displayExp);
        _builder.append("^{");
        String _displayExp_1 = this.displayExp(((Pow)exp).getRight());
        _builder.append(_displayExp_1);
        _builder.append("}");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      throw new Error("Invalid expression");
    }
    return _switchResult;
  }
  
  public CharSequence generateContentsCode(final EObject a, final Slide s) {
    if (a instanceof Animation) {
      return _generateContentsCode((Animation)a, s);
    } else if (a instanceof Block) {
      return _generateContentsCode((Block)a, s);
    } else if (a instanceof Code) {
      return _generateContentsCode((Code)a, s);
    } else if (a instanceof List) {
      return _generateContentsCode((List)a, s);
    } else if (a instanceof MathExp) {
      return _generateContentsCode((MathExp)a, s);
    } else if (a instanceof ShowImage) {
      return _generateContentsCode((ShowImage)a, s);
    } else if (a instanceof Table) {
      return _generateContentsCode((Table)a, s);
    } else if (a instanceof Text) {
      return _generateContentsCode((Text)a, s);
    } else if (a instanceof ToC) {
      return _generateContentsCode((ToC)a, s);
    } else if (a instanceof Image) {
      return _generateContentsCode((Image)a, s);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(a, s).toString());
    }
  }
}
