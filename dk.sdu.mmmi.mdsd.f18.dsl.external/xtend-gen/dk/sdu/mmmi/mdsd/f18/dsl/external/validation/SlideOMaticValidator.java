/**
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.validation;

import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Code;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Content;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FileCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SlideOMaticPackage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.validation.AbstractSlideOMaticValidator;
import java.io.File;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SlideOMaticValidator extends AbstractSlideOMaticValidator {
  public final static String UNBLOCKABLE_CONTENT = "unblockableContent";
  
  public final static String FILE_NOT_FOUND = "fileNotFound";
  
  public final static String LINE_NUMBER_TOO_HIGH = "lineNumberTooHigh";
  
  public final static String SLIDE_NAME_IS_EMPTY = "slideNameIsEnpty";
  
  public final static String EQUAL_LOCATIONS = "locationsAreEqual";
  
  @Check
  public void checkUnblockableContent(final Block block) {
    EList<Content> _content = block.getContent();
    for (final Content content : _content) {
      if ((content instanceof Code)) {
        this.error("Unable to put Code in a block", SlideOMaticPackage.Literals.BLOCK__CONTENT, SlideOMaticValidator.UNBLOCKABLE_CONTENT);
      }
    }
  }
  
  @Check
  public void checkSource(final Image img) {
    String _src = img.getSrc();
    final File f = new File(_src);
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.warning("Unable to find image source", SlideOMaticPackage.Literals.IMAGE__SRC, SlideOMaticValidator.FILE_NOT_FOUND);
    }
  }
  
  @Check
  public void checkSource(final FileCode code) {
    String _src = code.getSrc();
    final File f = new File(_src);
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.warning("Unable to find Code source", SlideOMaticPackage.Literals.FILE_CODE__SRC, SlideOMaticValidator.FILE_NOT_FOUND);
    }
  }
  
  @Check
  public Object checkLineSequence(final FileCode fc) {
    Object _xifexpression = null;
    if (((fc.getSrc() != null) && (fc.getLines() != null))) {
      Object _xblockexpression = null;
      {
        String _src = fc.getSrc();
        final File f = new File(_src);
        Object _xifexpression_1 = null;
        boolean _exists = f.exists();
        if (_exists) {
          _xifexpression_1 = null;
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  /**
   * Warn if a slide title is empty
   */
  @Check
  public void checkSlideTitleIsNotEmpty(final Slide s) {
    boolean _isEmpty = s.getName().isEmpty();
    if (_isEmpty) {
      this.warning("Slide name is empty", SlideOMaticPackage.Literals.SLIDE__NAME, SlideOMaticValidator.SLIDE_NAME_IS_EMPTY);
    }
  }
  
  /**
   * Warn if locations are the same in an animation
   */
  @Check
  public void checkAnimationLocations(final Animation a) {
    final String from = a.getFromLocation();
    final String final_ = a.getFinalLocation();
    final String via = a.getViaLocation();
    if ((from.equals(final_) || from.equals(via))) {
      this.warning("One or more locations are the same", SlideOMaticPackage.Literals.ANIMATION__FINAL_LOCATION, SlideOMaticValidator.EQUAL_LOCATIONS);
    } else {
      boolean _equals = final_.equals(via);
      if (_equals) {
        this.warning("One or more locations are the same", SlideOMaticPackage.Literals.ANIMATION__FINAL_LOCATION, SlideOMaticValidator.EQUAL_LOCATIONS);
      }
    }
  }
  
  /**
   * Warn that original image alignment will be ignored
   */
  @Check
  public void checkAnimationSourceAlignment(final Animation a) {
    final Image img = a.getTarget();
    String _alignment = img.getAlignment();
    boolean _tripleNotEquals = (_alignment != null);
    if (_tripleNotEquals) {
      this.warning("Original image alignment will be ignored", SlideOMaticPackage.Literals.ANIMATION__TARGET);
    }
  }
  
  /**
   * Warn about no image alignment
   */
  @Check
  public void checkImageAlignment(final Image i) {
    String _alignment = i.getAlignment();
    boolean _tripleEquals = (_alignment == null);
    if (_tripleEquals) {
      this.warning("No alignment specified. Default will be center", SlideOMaticPackage.Literals.IMAGE__ALIGNMENT);
    }
  }
}
