/**
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.f18.dsl.external.validation;

import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Animation;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Block;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Code;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.CompileDate;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Content;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Date;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.FileCode;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Image;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Slide;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.SlideOMaticPackage;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.Text;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.TextType;
import dk.sdu.mmmi.mdsd.f18.dsl.external.slideOMatic.URL;
import dk.sdu.mmmi.mdsd.f18.dsl.external.validation.AbstractSlideOMaticValidator;
import java.io.File;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SlideOMaticValidator extends AbstractSlideOMaticValidator {
  public final static String UNBLOCKABLE_CONTENT = "unblockableContent";
  
  public final static String FILE_NOT_FOUND = "fileNotFound";
  
  public final static String LINE_NUMBER_TOO_HIGH = "lineNumberTooHigh";
  
  public final static String SLIDE_NAME_IS_EMPTY = "slideNameIsEnpty";
  
  public final static String EQUAL_LOCATIONS = "locationsAreEqual";
  
  @Check
  public void checkUnblockableContent(final Block block) {
    EList<Content> _content = block.getContent();
    for (final Content content : _content) {
      if ((content instanceof Code)) {
        this.error("Unable to put Code in a block", SlideOMaticPackage.Literals.BLOCK__CONTENT, SlideOMaticValidator.UNBLOCKABLE_CONTENT);
      }
    }
  }
  
  @Check
  public void checkSource(final FileCode code) {
    String _src = code.getSrc();
    final File f = new File(_src);
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.warning("Unable to find Code source", SlideOMaticPackage.Literals.FILE_CODE__SRC, SlideOMaticValidator.FILE_NOT_FOUND);
    }
  }
  
  @Check
  public Object checkLineSequence(final FileCode fc) {
    Object _xifexpression = null;
    if (((fc.getSrc() != null) && (fc.getLines() != null))) {
      Object _xblockexpression = null;
      {
        String _src = fc.getSrc();
        final File f = new File(_src);
        Object _xifexpression_1 = null;
        boolean _exists = f.exists();
        if (_exists) {
          _xifexpression_1 = null;
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  /**
   * Check that manually written date is not empty
   */
  @Check
  public void checkDate(final Date d) {
    if ((!(d instanceof CompileDate))) {
      boolean _isEmpty = d.getDate().isEmpty();
      if (_isEmpty) {
        this.warning("Date is empty", SlideOMaticPackage.Literals.DATE__DATE);
      }
    }
  }
  
  /**
   * Check that a slide title is not empty
   */
  @Check
  public void checkSlideTitleIsNotEmpty(final Slide s) {
    boolean _isEmpty = s.getName().isEmpty();
    if (_isEmpty) {
      this.warning("Slide name is empty", SlideOMaticPackage.Literals.SLIDE__NAME, SlideOMaticValidator.SLIDE_NAME_IS_EMPTY);
    }
  }
  
  /**
   * Checks if url contains 'www'
   * Checks if url contains min. 2x'.'
   */
  @Check
  public void checkText(final Text txt) {
    final EList<TextType> types = txt.getTypes();
    final String t = txt.getText();
    for (final TextType tt : types) {
      if ((tt instanceof URL)) {
        boolean _contains = t.contains("www");
        boolean _not = (!_contains);
        if (_not) {
          this.warning("Url might be invalid. Check protocol", SlideOMaticPackage.Literals.TEXT__TEXT);
        }
        int _length = t.length();
        int _length_1 = t.replace(".", "").length();
        final int count = (_length - _length_1);
        if ((count < 2)) {
          this.warning("Url might be invalid. Check number of dots", SlideOMaticPackage.Literals.TEXT__TEXT);
        }
      }
    }
  }
  
  /**
   * Check that locations to, from, or via are not the same
   */
  @Check
  public void checkAnimationLocations(final Animation a) {
    final String from = a.getFromLocation();
    final String final_ = a.getFinalLocation();
    final String via = a.getViaLocation();
    if ((from.equals(final_) || from.equals(via))) {
      this.warning("One or more locations are the same", SlideOMaticPackage.Literals.ANIMATION__FINAL_LOCATION, SlideOMaticValidator.EQUAL_LOCATIONS);
    } else {
      boolean _equals = final_.equals(via);
      if (_equals) {
        this.warning("One or more locations are the same", SlideOMaticPackage.Literals.ANIMATION__FINAL_LOCATION, SlideOMaticValidator.EQUAL_LOCATIONS);
      }
    }
  }
  
  /**
   * Warn that original image alignment will be ignored
   */
  @Check
  public void checkAnimationSourceAlignment(final Animation a) {
    final Image img = a.getTarget();
    String _alignment = img.getAlignment();
    boolean _tripleNotEquals = (_alignment != null);
    if (_tripleNotEquals) {
      this.warning("Original image alignment will be ignored", SlideOMaticPackage.Literals.ANIMATION__TARGET);
    }
  }
  
  /**
   * Warn about no image alignment
   */
  @Check
  public void checkImageAlignment(final Image i) {
    String _alignment = i.getAlignment();
    boolean _tripleEquals = (_alignment == null);
    if (_tripleEquals) {
      this.warning("No alignment specified. Default will be center", SlideOMaticPackage.Literals.IMAGE__ALIGNMENT);
    }
  }
  
  /**
   * Check that image source cotains '.' for extension
   * Check if image source can be found
   */
  @Check
  public void checkImageSource(final Image img) {
    String _src = img.getSrc();
    final File f = new File(_src);
    boolean _exists = f.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.warning("Unable to find image source", SlideOMaticPackage.Literals.IMAGE__SRC, SlideOMaticValidator.FILE_NOT_FOUND);
    }
    boolean _contains = img.getSrc().contains(".");
    boolean _not_1 = (!_contains);
    if (_not_1) {
      this.warning("Image has no extension", SlideOMaticPackage.Literals.IMAGE__SRC);
    }
  }
}
